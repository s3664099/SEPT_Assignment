"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _synchronousPromise = require("synchronous-promise");

var _Cancel = _interopRequireDefault(require("./cancel/Cancel"));

var _CancelToken = _interopRequireDefault(require("./cancel/CancelToken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** a FIFO queue of pending request */
var _pending_requests = [];

var _newReq = function _newReq() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var url = config.url;
  var data = config.data;

  var promise = _synchronousPromise.SynchronousPromise.unresolved();

  _pending_requests.push({
    config: config,
    data: data,
    promise: promise,
    url: url
  });

  return promise;
};

var _helperReq = function _helperReq(url, data, config) {
  var conf = data && config ? config : {};
  return _newReq(_objectSpread({}, conf, {
    data: data,
    url: url
  }));
};

var MockAxios = jest.fn(_newReq); // mocking Axios methods

MockAxios.get = jest.fn(_helperReq);
MockAxios.post = jest.fn(_helperReq);
MockAxios.put = jest.fn(_helperReq);
MockAxios.patch = jest.fn(_helperReq);
MockAxios["delete"] = jest.fn(_helperReq);
MockAxios.request = jest.fn(_newReq);
MockAxios.all = jest.fn(function (values) {
  return Promise.all(values);
});
MockAxios.head = jest.fn(_helperReq);
MockAxios.options = jest.fn(_helperReq);
MockAxios.create = jest.fn(function () {
  return MockAxios;
});
MockAxios.interceptors = {
  request: {
    use: jest.fn()
  },
  response: {
    use: jest.fn()
  }
};
MockAxios.defaults = {
  headers: {
    common: []
  }
};

MockAxios.popPromise = function (promise) {
  if (promise) {
    // remove the promise from pending queue
    for (var ix = 0; ix < _pending_requests.length; ix++) {
      var req = _pending_requests[ix];

      if (req.promise === promise) {
        _pending_requests.splice(ix, 1);

        return req.promise;
      }
    }
  } else {
    // take the oldest promise
    var _req = _pending_requests.shift();

    return _req ? _req.promise : void 0;
  }
};

MockAxios.popRequest = function (request) {
  if (request) {
    var ix = _pending_requests.indexOf(request);

    if (ix === -1) {
      return void 0;
    }

    _pending_requests.splice(ix, 1);

    return request;
  } else {
    return _pending_requests.shift();
  }
};
/**
 * Removes an item form the queue, based on it's type
 * @param queueItem
 */


var popQueueItem = function popQueueItem() {
  var queueItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  // first let's pretend the param is a queue item
  var request = MockAxios.popRequest(queueItem);

  if (request) {
    // IF the request was found
    // > set the promise
    return request.promise;
  } else {
    // ELSE maybe the `queueItem` is a promise (legacy mode)
    return MockAxios.popPromise(queueItem);
  }
};

MockAxios.mockResponse = function (response) {
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // replacing missing data with default values
  response = Object.assign({
    config: {},
    data: {},
    headers: {},
    status: 200,
    statusText: "OK"
  }, response);
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.resolve(response);
};

MockAxios.mockError = function () {
  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error("No request to respond to!");
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.reject(error);
};

MockAxios.lastReqGet = function () {
  return _pending_requests[_pending_requests.length - 1];
};

MockAxios.lastPromiseGet = function () {
  var req = MockAxios.lastReqGet();
  return req ? req.promise : void 0;
};

MockAxios.getReqByUrl = function (url) {
  return _pending_requests.slice().reverse() // reverse cloned array to return most recent req
  .find(function (x) {
    return x.url === url;
  });
};

MockAxios.reset = function () {
  // remove all the requests
  _pending_requests.splice(0, _pending_requests.length); // resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays


  MockAxios.get.mockClear();
  MockAxios.post.mockClear();
  MockAxios.put.mockClear();
  MockAxios.patch.mockClear();
  MockAxios["delete"].mockClear();
  MockAxios.head.mockClear();
  MockAxios.options.mockClear();
  MockAxios.request.mockClear();
  MockAxios.all.mockClear();
};

MockAxios.Cancel = _Cancel["default"];
MockAxios.CancelToken = _CancelToken["default"];

MockAxios.isCancel = function (u) {
  return !!(u && u.__CANCEL__);
}; // this is a singleton object


var _default = MockAxios;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9tb2NrLWF4aW9zLnRzIl0sIm5hbWVzIjpbIl9wZW5kaW5nX3JlcXVlc3RzIiwiX25ld1JlcSIsImNvbmZpZyIsInVybCIsImRhdGEiLCJwcm9taXNlIiwiU3luY2hyb25vdXNQcm9taXNlIiwidW5yZXNvbHZlZCIsInB1c2giLCJfaGVscGVyUmVxIiwiY29uZiIsIk1vY2tBeGlvcyIsImplc3QiLCJmbiIsImdldCIsInBvc3QiLCJwdXQiLCJwYXRjaCIsInJlcXVlc3QiLCJhbGwiLCJ2YWx1ZXMiLCJQcm9taXNlIiwiaGVhZCIsIm9wdGlvbnMiLCJjcmVhdGUiLCJpbnRlcmNlcHRvcnMiLCJ1c2UiLCJyZXNwb25zZSIsImRlZmF1bHRzIiwiaGVhZGVycyIsImNvbW1vbiIsInBvcFByb21pc2UiLCJpeCIsImxlbmd0aCIsInJlcSIsInNwbGljZSIsInNoaWZ0IiwicG9wUmVxdWVzdCIsImluZGV4T2YiLCJwb3BRdWV1ZUl0ZW0iLCJxdWV1ZUl0ZW0iLCJtb2NrUmVzcG9uc2UiLCJzaWxlbnRNb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIkVycm9yIiwicmVzb2x2ZSIsIm1vY2tFcnJvciIsImVycm9yIiwicmVqZWN0IiwibGFzdFJlcUdldCIsImxhc3RQcm9taXNlR2V0IiwiZ2V0UmVxQnlVcmwiLCJzbGljZSIsInJldmVyc2UiLCJmaW5kIiwieCIsInJlc2V0IiwibW9ja0NsZWFyIiwiQ2FuY2VsIiwiQ2FuY2VsVG9rZW4iLCJpc0NhbmNlbCIsInUiLCJfX0NBTkNFTF9fIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBUUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFPQTtBQUNBLElBQU1BLGlCQUF1QyxHQUFHLEVBQWhEOztBQUVBLElBQU1DLE9BQTRELEdBQUcsU0FBL0RBLE9BQStELEdBQXNCO0FBQUEsTUFBckJDLE1BQXFCLHVFQUFQLEVBQU87QUFDdkYsTUFBTUMsR0FBVyxHQUFHRCxNQUFNLENBQUNDLEdB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QUFrQjBDLFNBQWxCO0FBQ0FqRCxFQUFBQSxTQUFTLENBQUNRLEdBQVYsQ0FBY3lDLFNBQWQ7QUFDSCxDQWREOztBQWdCQWpELFNBQVMsQ0FBQ2tELE1BQVYsR0FBbUJBLGtCQUFuQjtBQUNBbEQsU0FBUyxDQUFDbUQsV0FBVixHQUF3QkEsdUJBQXhCOztBQUNBbkQsU0FBUyxDQUFDb0QsUUFBVixHQUFxQixVQUFDQyxDQUFELEVBQW9CO0FBQ3JDLFNBQU8sQ0FBQyxFQUFFQSxDQUFDLElBQUlBLENBQUMsQ0FBQ0MsVUFBVCxDQUFSO0FBQ0gsQ0FGRCxDLENBSUE7OztlQUNldEQsUyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVHlwZVNjcmlwdCB2ZXJzaW9uIG9mIEF4aW9zIG1vY2sgZm9yIHVuaXQgdGVzdGluZyB3aXRoIFtKZXN0XShodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9qZXN0LykuXG4gKiBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdHV4NC8zNjAwNmExODU5MzIzZjc3OWFiMFxuICpcbiAqIEBhdXRob3IgICBrbmVlLWNvbGEgPG5pa29sYS5kZXJlemljQGdtYWlsLmNvbT5cbiAqIEBsaWNlbnNlICBAbGljZW5zZSBNSVQgTGljZW5zZSwgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG5pbXBvcnQgeyBTeW5jaHJvbm91c1Byb21pc2UsIFVucmVzb2x2ZWRTeW5jaHJvbm91c1Byb21pc2UgIH0gZnJvbSBcInN5bmNocm9ub3VzLXByb21pc2VcIjtcbmltcG9ydCBDYW5jZWwgZnJvbSBcIi4vY2FuY2VsL0NhbmNlbFwiO1xuaW1wb3J0IENhbmNlbFRva2VuIGZyb20gXCIuL2NhbmNlbC9DYW5jZWxUb2tlblwiO1xuaW1wb3J0IHtcbiAgICBBeGlvc01vY2tRdWV1ZUl0ZW0sXG4gICAgQXhpb3NNb2NrVHlwZSxcbiAgICBIdHRwUmVzcG9uc2UsXG59IGZyb20gXCIuL21vY2stYXhpb3MtdHlwZXNcIjtcblxuLyoqIGEgRklGTyBxdWV1ZSBvZiBwZW5kaW5nIHJlcXVlc3QgKi9cbmNvbnN0IF9wZW5kaW5nX3JlcXVlc3RzOiBBeGlvc01vY2tRdWV1ZUl0ZW1bXSA9IFtdO1xuXG5jb25zdCBfbmV3UmVxOiAoY29uZmlnPzogYW55KSA9PiBVbnJlc29sdmVkU3luY2hyb25vdXNQcm9taXNlPGFueT4gPSAoY29uZmlnOiBhbnkgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHVybDogc3RyaW5nID0gY29uZmlnLnVybDtcbiAgICBjb25zdCBkYXRhOiBhbnkgPSBjb25maWcuZGF0YTtcbiAgICBjb25zdCBwcm9taXNlOiBVbnJlc29sdmVkU3luY2hyb25vdXNQcm9taXNlPGFueT4gPSBTeW5jaHJvbm91c1Byb21pc2UudW5yZXNvbHZlZCgpO1xuICAgIF9wZW5kaW5nX3JlcXVlc3RzLnB1c2goe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIHVybCxcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbmNvbnN0IF9oZWxwZXJSZXEgPSAodXJsOiBzdHJpbmcsIGRhdGE/OiBhbnksIGNvbmZpZz86IGFueSkgPT4ge1xuICAgIGNvbnN0IGNvbmYgPSBkYXRhICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9O1xuICAgIHJldHVybiBfbmV3UmVxKHtcbiAgICAgICAgLi4uY29uZixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdXJsLFxuICAgIH0pO1xufTtcblxuY29uc3QgTW9ja0F4aW9zOiBBeGlvc01vY2tUeXBlID0gKGplc3QuZm4oX25ld1JlcSkgYXMgdW5rbm93bikgYXMgQXhpb3NNb2NrVHlwZTtcblxuLy8gbW9ja2luZyBBeGlvcyBtZXRob2RzXG5Nb2NrQXhpb3MuZ2V0ID0gamVzdC5mbihfaGVscGVyUmVxKTtcbk1vY2tBeGlvcy5wb3N0ID0gamVzdC5mbihfaGVscGVyUmVxKTtcbk1vY2tBeGlvcy5wdXQgPSBqZXN0LmZuKF9oZWxwZXJSZXEpO1xuTW9ja0F4aW9zLnBhdGNoID0gamVzdC5mbihfaGVscGVyUmVxKTtcbk1vY2tBeGlvcy5kZWxldGUgPSBqZXN0LmZuKF9oZWxwZXJSZXEpO1xuTW9ja0F4aW9zLnJlcXVlc3QgPSBqZXN0LmZuKF9uZXdSZXEpO1xuTW9ja0F4aW9zLmFsbCA9IGplc3QuZm4oKHZhbHVlcykgPT4gUHJvbWlzZS5hbGwodmFsdWVzKSk7XG5Nb2NrQXhpb3MuaGVhZCA9IGplc3QuZm4oX2hlbHBlclJlcSk7XG5Nb2NrQXhpb3Mub3B0aW9ucyA9IGplc3QuZm4oX2hlbHBlclJlcSk7XG5Nb2NrQXhpb3MuY3JlYXRlID0gamVzdC5mbigoKSA9PiBNb2NrQXhpb3MpO1xuXG5Nb2NrQXhpb3MuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgdXNlOiBqZXN0LmZuKCksXG4gICAgfSxcbiAgICByZXNwb25zZToge1xuICAgICAgICB1c2U6IGplc3QuZm4oKSxcbiAgICB9LFxufTtcblxuTW9ja0F4aW9zLmRlZmF1bHRzID0ge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICAgY29tbW9uOiBbXSxcbiAgICB9LFxufTtcblxuTW9ja0F4aW9zLnBvcFByb21pc2UgPSAocHJvbWlzZT86IFN5bmNocm9ub3VzUHJvbWlzZTxhbnk+KSA9PiB7XG4gICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBwcm9taXNlIGZyb20gcGVuZGluZyBxdWV1ZVxuICAgICAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwgX3BlbmRpbmdfcmVxdWVzdHMubGVuZ3RoOyBpeCsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXE6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IF9wZW5kaW5nX3JlcXVlc3RzW2l4XTtcblxuICAgICAgICAgICAgaWYgKHJlcS5wcm9taXNlID09PSBwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKGl4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0YWtlIHRoZSBvbGRlc3QgcHJvbWlzZVxuICAgICAgICBjb25zdCByZXE6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IF9wZW5kaW5nX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiByZXEgPyByZXEucHJvbWlzZSA6IHZvaWQgMDtcbiAgICB9XG59O1xuXG5Nb2NrQXhpb3MucG9wUmVxdWVzdCA9IChyZXF1ZXN0PzogQXhpb3NNb2NrUXVldWVJdGVtKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgaXggPSBfcGVuZGluZ19yZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpO1xuICAgICAgICBpZiAoaXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKGl4LCAxKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9wZW5kaW5nX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZm9ybSB0aGUgcXVldWUsIGJhc2VkIG9uIGl0J3MgdHlwZVxuICogQHBhcmFtIHF1ZXVlSXRlbVxuICovXG5jb25zdCBwb3BRdWV1ZUl0ZW0gPSAocXVldWVJdGVtOiBTeW5jaHJvbm91c1Byb21pc2U8YW55PiB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwpID0+IHtcbiAgICAvLyBmaXJzdCBsZXQncyBwcmV0ZW5kIHRoZSBwYXJhbSBpcyBhIHF1ZXVlIGl0ZW1cbiAgICBjb25zdCByZXF1ZXN0OiBBeGlvc01vY2tRdWV1ZUl0ZW0gPSBNb2NrQXhpb3MucG9wUmVxdWVzdChcbiAgICAgICAgcXVldWVJdGVtIGFzIEF4aW9zTW9ja1F1ZXVlSXRlbSxcbiAgICApO1xuXG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgLy8gSUYgdGhlIHJlcXVlc3Qgd2FzIGZvdW5kXG4gICAgICAgIC8vID4gc2V0IHRoZSBwcm9taXNlXG4gICAgICAgIHJldHVybiByZXF1ZXN0LnByb21pc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRUxTRSBtYXliZSB0aGUgYHF1ZXVlSXRlbWAgaXMgYSBwcm9taXNlIChsZWdhY3kgbW9kZSlcbiAgICAgICAgcmV0dXJuIE1vY2tBeGlvcy5wb3BQcm9taXNlKHF1ZXVlSXRlbSBhcyBVbnJlc29sdmVkU3luY2hyb25vdXNQcm9taXNlPGFueT4pO1xuICAgIH1cbn07XG5cbk1vY2tBeGlvcy5tb2NrUmVzcG9uc2UgPSAoXG4gICAgcmVzcG9uc2U/OiBIdHRwUmVzcG9uc2UsXG4gICAgcXVldWVJdGVtOiBTeW5jaHJvbm91c1Byb21pc2U8YW55PiB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwsXG4gICAgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuKTogdm9pZCA9PiB7XG4gICAgLy8gcmVwbGFjaW5nIG1pc3NpbmcgZGF0YSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgcmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJPS1wiLFxuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZSxcbiAgICApO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IHBvcFF1ZXVlSXRlbShxdWV1ZUl0ZW0pO1xuXG4gICAgaWYgKCFwcm9taXNlICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcHJvbWlzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcbiAgICBwcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xufTtcblxuTW9ja0F4aW9zLm1vY2tFcnJvciA9IChcbiAgICBlcnJvcjogYW55ID0ge30sXG4gICAgcXVldWVJdGVtOiBTeW5jaHJvbm91c1Byb21pc2U8YW55PiB8IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IG51bGwsXG4gICAgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlLFxuKSA9PiB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHBvcFF1ZXVlSXRlbShxdWV1ZUl0ZW0pO1xuXG4gICAgaWYgKCFwcm9taXNlICYmICFzaWxlbnRNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgdG8gcmVzcG9uZCB0byFcIik7XG4gICAgfSBlbHNlIGlmICghcHJvbWlzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2aW5nIHRoZSBQcm9taXNlIHdpdGggdGhlIGdpdmVuIHJlc3BvbnNlIGRhdGFcbiAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG59O1xuXG5Nb2NrQXhpb3MubGFzdFJlcUdldCA9ICgpID0+IHtcbiAgICByZXR1cm4gX3BlbmRpbmdfcmVxdWVzdHNbX3BlbmRpbmdfcmVxdWVzdHMubGVuZ3RoIC0gMV07XG59O1xuXG5Nb2NrQXhpb3MubGFzdFByb21pc2VHZXQgPSAoKSA9PiB7XG4gICAgY29uc3QgcmVxID0gTW9ja0F4aW9zLmxhc3RSZXFHZXQoKTtcbiAgICByZXR1cm4gcmVxID8gcmVxLnByb21pc2UgOiB2b2lkIDA7XG59O1xuXG5Nb2NrQXhpb3MuZ2V0UmVxQnlVcmwgPSAodXJsOiBzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gX3BlbmRpbmdfcmVxdWVzdHNcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKSAvLyByZXZlcnNlIGNsb25lZCBhcnJheSB0byByZXR1cm4gbW9zdCByZWNlbnQgcmVxXG4gICAgICAgIC5maW5kKCh4OiBBeGlvc01vY2tRdWV1ZUl0ZW0pID0+IHgudXJsID09PSB1cmwpO1xufTtcblxuTW9ja0F4aW9zLnJlc2V0ID0gKCkgPT4ge1xuICAgIC8vIHJlbW92ZSBhbGwgdGhlIHJlcXVlc3RzXG4gICAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKDAsIF9wZW5kaW5nX3JlcXVlc3RzLmxlbmd0aCk7XG5cbiAgICAvLyByZXNldHMgYWxsIGluZm9ybWF0aW9uIHN0b3JlZCBpbiB0aGUgbW9ja0ZuLm1vY2suY2FsbHMgYW5kIG1vY2tGbi5tb2NrLmluc3RhbmNlcyBhcnJheXNcbiAgICBNb2NrQXhpb3MuZ2V0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5wb3N0Lm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5wdXQubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLnBhdGNoLm1vY2tDbGVhcigpO1xuICAgIE1vY2tBeGlvcy5kZWxldGUubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLmhlYWQubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLm9wdGlvbnMubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLnJlcXVlc3QubW9ja0NsZWFyKCk7XG4gICAgTW9ja0F4aW9zLmFsbC5tb2NrQ2xlYXIoKTtcbn07XG5cbk1vY2tBeGlvcy5DYW5jZWwgPSBDYW5jZWw7XG5Nb2NrQXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbk1vY2tBeGlvcy5pc0NhbmNlbCA9ICh1KTogdSBpcyBDYW5jZWwgPT4ge1xuICAgIHJldHVybiAhISh1ICYmIHUuX19DQU5DRUxfXyk7XG59O1xuXG4vLyB0aGlzIGlzIGEgc2luZ2xldG9uIG9iamVjdFxuZXhwb3J0IGRlZmF1bHQgTW9ja0F4aW9zO1xuIl19